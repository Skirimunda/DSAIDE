---
title: "DSAIDE Package Tutorial"
author: "Andreas Handel"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    #css: dsaidevignettestyle.css
vignette: >
  %\VignetteIndexEntry{DSAIDE}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---




## Introduction
DSAIDE stands for Dynamical Systems Approaches to Infectious Disease Epidemiology.

The idea behind this package is to give students and others interested in infectious diseases at the population level a tool that allows them to learn about patterns and features seen in infectious disease epidemiology using a dynamical systems approach.



## Package description

The package consists of several Shiny Apps that allow the simulation and exploration of different topics in infectious disease epidemiology. 

There are currently 11 simulations/apps available, briefly described in the table below:



| App Name                | Model      | Topic Covered | 
|------                   | --------   |---------------|
|   ID Dynamics Intro     | 3 compartment (SIR) ODE model | A first introduction to a simple compartmental SIR model. Allows simulation of a single outbreak for different parameter and initial condition settings.       |  
|   Characteristics of ID     | 6 compartment ODE model | The potential role of different disease states (e.g. pre-symptomatic, asymptomatic, symptomatic) on ID dynamics. |  
|   ID Patterns     | 6 compartment ODE model. Includes births-deaths, waning immunity, seasonality. | Different ID patterns (single outbreak, osciallations, steady states). |  
|   Direct Transmission   | 3 compartment ODE model. Births-deaths and waning immunity are included. | The differences between density-dependent and frequency-dependent transmission and their impact on ID dynamics.  |  
|   Environmental Transmission   | 4 compartment ODE model. Includes explicit environmental stage. Births-deaths and waning immunity are included. | The impact of environmental shedding, decay and transmission.  |  
|   Vector Transmission   | 5 compartment ODE model. Includes susceptible and infected vectors and their dynamics. Births-deaths for vectors and waning immunity for hosts are included. | Exploration of a simple vector-borne transmission model. |  
|   Reproductive Number  | 3 compartment ODE model.  Includes vaccination of population at beginning of simulation. Births-deaths and waning immunity are included. | The reproductive number concept and how to estimate it from (simulated) data. |  
|   ID Control  | 9 compartment ODE model. An environmental and 2 vector stages as well as 6 host stages. | The impact of different control measures for different types of ID. |  
|   Host Heterogeneity | 6 compartment ODE model. 2x SIR for 2 different hosts. | The impact of host heterogeneity and core groups on ID dynamics and control. |  
|   Stochastic dynamics  | 4 compartment (SEIR) stochastic model. | The impact of stochasticity on dynamics, the phenomenon of ID extinction. |  
|   Evolutionary dynamics  | 5 compartment stochastic model. Untreated and treated hosts infected with wild-type, and hosts infected with resistant strain. | Interaction between drug treatment and evolution/emergence of drug resistance. |  





Each App is meant to be fully self-explanatory. The app contains a description of the model, a list of tasks students should try, and information for further details. 


The underlying models are written mostly as deterministic, compartmental ordinary differential equations. Some models are written as stochastic equivalents. By wrapping the models around a graphical user interface, it allows exploration of models and infectious disease patterns without the need to write R code.

At the same time, the package is structured in a modular way that should allow those interested in the actual models and learning R coding to easily move from one stage to another.



##Interacting with and using the package
The following sections describe the main envisioned ways the content in this R package can be used and extended. The idea is that everyone starts at level 1, and then depending on their needs and interests, can decide to move on to the next level.


###Level 1: Interactive use through the Shiny user interface

The interactive exploration of the models through the Shiny user interfacie is the main intended use of this package. The steps to get there are simple. Install the package (only needs to be done once):
```{r, eval=FALSE, echo=TRUE}
install.packages('DSAIDE')
```

Then load the package:
```{r, eval=TRUE, echo=TRUE}
library("DSAIDE")
```

Finally, call the main menu for the package:
```{r, eval=FALSE, echo=TRUE}
dsaidemenu()
```

This will bring up a simple graphical menu from which the user can select each App. After exploring an App, the user returns to the main menu and eventually exits the main menu. In this way, no coding experience is needed, the student can fully focus on learning the infectious disease dynamics related topics.

Each app contains the information needed to understand the underlying model, and has a list of (non exhaustive) tasks that a student can try to get a better understanding of the topic meant to be covered by the App.  




###Level 2: Supplementing simulations with custom code
Each App is structured in such a way that the underlying model/simulation is a stand-alone function. This simulator function can be called directly, without going through the Shiny App. Consider as example the first App, called "ID Dynamics Intro". The model is a simple SIR model. The function running this model is called `simulate_introduction.R`, the user can learn about the inputs and outputs of the function by looking at its documentation
```{r eval=FALSE, echo=TRUE}
?simulate_introduction
```

The help file explains that one can run the simulation by specifying initial number of susceptibles and infected, the duration for which the simulation should be run, and the rates of infection and recovery. Most models do not have inherent time units and are set by the user based on choices for parameters. It is important to ensure that all quantities that have time units (here, _tmax_, _g_ and _b_) are expressed in the same time units, e.g. days or months (or the inverse of those units for rates).   

```{r, eval=TRUE, echo=TRUE}
result <- simulate_introduction(S0 = 1000, I0 = 1, tmax = 300, g = 0.5,  b = 1/1000)
```
Calling the simulation function produces time-series for the dynamics of each of the variables that are tracked. 
The Shiny app automatically produce plots of these time-series. Users can produce their own plots, e.g. such as
```{r, eval=TRUE, echo=TRUE}
plot(result[,"time"],result[,"S"],xlab='Time',ylab='Number Susceptible',type='l')
```

The more interesting use of these simulator functions outside of the Shiny App is that it allows additional exploration of the models. For instance it is possible to systematically loop over a parameter, record some quantity of interest for each run, and report the result at the end. The following is a simple example, where we loop over different values of the recovery rate and record the peak of the outbreak each time:

```{r, eval=TRUE, echo=TRUE}
gvec = seq(0.1,2,by=0.1) #values of g which we went to run the simulation for
peak = rep(0,length(gvec)) #this will hold the peak values for each g
for (n in 1:length(gvec))
{
  result <- simulate_introduction(S0 = 1000, I0 = 1, tmax = 300, g = gvec[n],  b = 1/1000)
  peak[n] <- max(result[,"I"])
}
plot(gvec,peak,type='p',xlab='Rate of recovery',ylab='Max number of infected')
```

Thus, the user can add their own custom code to the existing simulator functions and with a few lines of extra code analyze and explore many more questions and scenarios than those accessible through the Shiny App interface. This gives the user a lot more flexibility using these simulations, but requires being able to write some R code to interface with the supplied simulator functions. 


###Level 3: Modifying simulations
Finally, there is an option for the user to access and modify the underlying simulator functions directly. To facilitate this, all simulator functions are in a subdirectory called _simulatorfunctions_ inside the DSAIDE package folder. You might have to search your computer to see where R installed the package. 

I suggest that you copy the whole folder to some new directory and then modify the function you are interested in. 
All simulator functions are (hopefully) well documented. So as long as you are familiar with R coding, you should have no problem modifying the function to your needs. After editing the simulator function to suit your needs, you will likely also need to write additional code to interact with your modified function as described in _Level 2_.

The following provides a simple example of this process. Let's assume for simplicity that you want to modify the simple SIR model encoded in simulate_introduction.R. You find the file, make a copy - let's call it mysimulator.R and edit. Say you want to include waning immunity with recovered returning to the susceptible class at rate _w_. 

You will need to modify the following lines in your code:

old:
```{r eval=FALSE, echo=TRUE}
simulate_introduction <- function(S0 = 1000, I0 = 1, tmax = 300, g = 0.5, b = 1/1000)
```

new:
```{r eval=FALSE, echo=TRUE}
mysimulator <- function(S0 = 1000, I0 = 1, tmax = 300, g = 0.5, b = 1/1000, w = 0)
```

old:
```{r eval=FALSE, echo=TRUE}
pars = c(b = b, g = g);
```

new:
```{r eval=FALSE, echo=TRUE, color='red'}
pars = c(b = b, g = g, w = w);
```


old:
```{r eval=FALSE, echo=TRUE}
dS =  - b * S * I; #susceptibles
dI = b * S * I - g * I; #infected/infectious
dR = g * I; #recovered
```

new:
```{r eval=FALSE, echo=TRUE}
dS =  - b * S * I + w * R; #susceptibles
dI = b * S * I - g * I; #infected/infectious
dR = g * I -  w * R; #recovered
```


If you now wanted to explore how different rates of waning immunity impact the maximum peak size over all outbreaks, you can for instance run:


```{r eval=FALSE, echo=TRUE}
wvec = seq(0,2,by=0.1) #values of w which we went to run the simulation for
peak = rep(0,length(wvec)) #this will hold the peak values for each w
for (n in 1:length(wvec))
{
  result <- mysimulator(S0 = 1000, I0 = 1, tmax = 300, g = 0.5,  b = 1/1000, w = wvec[n])
  peak[n] <- max(result[,"I"])
}
plot(wvec,peak,type='p')
```




###Level 4: Developing a new Shiny app
I would love to add further Shiny apps to the package. I have tried to make it (hopefully) easy to develop further Shiny Apps. There is some information in the package to help with development in a sub-folder called _docsfordevelopers_. Essentially, each app consists of a simulator function and a shiny App function which calls the simulator function, together with documentation for the App. Developing a new App then consists of writing at minimum 2 R functions (_simulate_NNN.R_ and the corresponding _app.R_) and filling the provided Rmd template for the documentation, then running a few functions to process everything. See the information in the _docsfordevelopers_ folder for more details. 


